      Subroutine Type9031
!-----------------------------------------------------------------------------------------------------------------------
! DESCRIPTION: Given valve positions, pump speeds, and some temperatures, 
! calculate the pressures, flow rates, and temperatures in the hydronic system.
! Also calculate the pump power consumption

! Object: Hydronic System Control
! Simulation Studio Model: Pressure Calculation

! Author: Laith Abdulmajeid and Gregory Nellis
! Editor: Laith Abdulmajeid and Amanda Pertzborn
! Date:	 March 30, 2022
! last modified: March 20 , 2024
! 
! 
! *** Model Parameters 
! *** 
!			P_low 		lowest system pressure, 10 psi default [psi]  [-Inf,+Inf]

! *** 
! *** Model Inputs 
! *** 
!			N_P1 		pump1 speed [rpm] [0,+Inf]
!			N_P2 		pump2 speed [rpm] [0,+Inf]
!			N_P3 		pump3 speed [rpm] [0,+Inf]
!			N_P5 		pump5 speed [rpm] [0,+Inf]
!			f_V8 		fractional position of V8 (valve) [-] [0,1]
!			f_V10 		fractional position of V10 (valve) [-] [0,1]
!			f_V12 		fractional position of V12 (valve) [-] [0,1]
!			f_V13 		fractional position of V13 (valve) [-] [0,1]
!			f_V18 		fractional position of V18 (valve) [-] [0,1]
!			f_V19 		fractional position of V19 (valve) [-] [0,1]
!			f_V20 		fractional position of V20 (valve) [-] [0,1]
!			T_PL_out 	temperature of the fluid leaving the primary loop [C] [-Inf,+Inf]
!			T_SL_out 	temperature of the fluid leaving the secondary loop [C] [-Inf,+Inf]
!			T_chwst 	chilled water setpoint temperature [C] [-Inf,+Inf]
! *** Model Outputs 
! *** 
!			P1			pressure at location 1 [psi]  [-Inf,+Inf]
!			P2			pressure at location 2 [psi]  [-Inf,+Inf]
!			P3			pressure at location 3 [psi]  [-Inf,+Inf]
!			P4			pressure at location 4 [psi]  [-Inf,+Inf]
!			P5			pressure at location 5 [psi]  [-Inf,+Inf]
!			P6			pressure at location 6 [psi]  [-Inf,+Inf]
!			P7			pressure at location 7 [psi]  [-Inf,+Inf]
!			P8			pressure at location 8 [psi]  [-Inf,+Inf]
!			P9			pressure at location 9 [psi]  [-Inf,+Inf]
!			P10			pressure at location 10 [psi]  [-Inf,+Inf]
!			P11			pressure at location 11 [psi]  [-Inf,+Inf]
!			P12			pressure at location 12 [psi]  [-Inf,+Inf]
!			P13			pressure at location 13 [psi]  [-Inf,+Inf]
!			P14			pressure at location 14 [psi]  [-Inf,+Inf]
!			P15			pressure at location 15 [psi]  [-Inf,+Inf]
!			P16			pressure at location 16 [psi]  [-Inf,+Inf]
!			P17			pressure at location 17 [psi]  [-Inf,+Inf]
!			P18			pressure at location 18 [psi]  [-Inf,+Inf]
!			P19			pressure at location 19 [psi]  [-Inf,+Inf]
!			P20			pressure at location 20 [psi]  [-Inf,+Inf]
!			Q_PL 		flow rate in the primary loop [gpm] [-Inf,+Inf]
!			Q_SL 		flow rate in the secondary loop [gpm] [-Inf,+Inf]
!			Q_AHU1 		flow rate in the AHU1 cooling coil [gpm] [-Inf,+Inf]
!			Q_AHU2 		flow rate in the AHU2 cooling coil [gpm] [-Inf,+Inf]
!			Q_BTSE 		flow rate in the bypass around the thermal energy storage [gpm] [-Inf,+Inf]
!			Q_TSE 		flow rate in the thermal energy storage [gpm] [-Inf,+Inf]
!			Q_HX1 		flow rate in heat exchanger 1 [gpm] [-Inf,+Inf]
!			Q_C1 		flow rate in Chiller1 [gpm] [-Inf,+Inf]
!			Q_C2 		flow rate in Chiller2 [gpm] [-Inf,+Inf]
!			Q_DC 		flow rate in the bridge between the primary and secondary loops [gpm] [-Inf,+Inf]
!			Q_WSE 		flow rate in the water side economizer [gpm] [-Inf,+Inf]
!			power_P3 	power consumption of Pump3 [W] [0,+Inf]
!			power_P1 	power consumption of Pump1 [W] [0,+Inf]
!			power_P2 	power consumption of Pump2 [W] [0,+Inf]
!			power_P3 	power consumption of Pump5 [W] [0,+Inf]
!			T_SL_in 	temperature of the fluid entering the secondary loop [C] [-Inf,+Inf]
!			T_PL_in 	temperature of the fluid entering the primary loop [C] [-Inf,+Inf]
! *** 
! *** Model Derivatives 
! *** 

! (Comments and routine interface generated by TRNSYS Simulation Studio)
!************************************************************************

!-----------------------------------------------------------------------------------------------------------------------
! This TRNSYS component skeleton was generated from the TRNSYS studio based on the user-supplied parameters, inputs, 
! outputs, and derivatives.  The user should check the component formulation carefully and add the content to transform
! the parameters, inputs and derivatives into outputs.  Remember, outputs should be the average value over the timestep
! and not the value at the end of the timestep; although in many models these are exactly the same values.  Refer to 
! existing types for examples of using advanced features inside the model (Formats, Labels etc.)
!-----------------------------------------------------------------------------------------------------------------------


      Use TrnsysConstants
      Use TrnsysFunctions

!-----------------------------------------------------------------------------------------------------------------------

!DEC$Attributes DLLexport :: Type9031

!-----------------------------------------------------------------------------------------------------------------------
!Trnsys Declarations
      Implicit None

      Double Precision Timestep,Time
      Integer CurrentUnit,CurrentType, luw, it, itMax
     
      Double Precision P(20)
      Double Precision Q_PL,Q_SL,Q_C1,Q_C2,Q_BTSE,Q_TSE,Q_DC,Q_AHU1,Q_AHU2,Q_HX1,Q_WSE,Pout
      double precision err_SL, tol_SL, Q_SL_c, DQ_PL, Q_PL_c, i, DP
	  double precision Q_PLv(19), Q_PL_cv(19), errv(19), dQ,dDPdQ
      double precision power_P3, power_P1, power_P2, power_P5
      double precision T_SL_in,T_PL_in, PLknown, s(2),ys(2),xs(2),slope,intercept,x_idx,Q_PL_min,T_chwst,mult
      integer j, idx, skip

!    PARAMETERS
      DOUBLE PRECISION P_low

!    INPUTS
      DOUBLE PRECISION N_P1,N_P2,N_P3,N_P5
      Double Precision f_V8,f_V10,f_V12,f_V13,f_V18,f_V19,f_V20,T_SL_out,T_PL_out

!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Get the Global Trnsys Simulation Variables
      Time=getSimulationTime()
      Timestep=getSimulationTimeStep()
      CurrentUnit = getCurrentUnit()
      CurrentType = getCurrentType()
	  luw = getListingFileLogicalUnit()
      itMax = 100
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Set the Version Number for This Type
      If(getIsVersionSigningTime()) Then
		Call SetTypeVersion(17)
		Return
      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Do Any Last Call Manipulations Here
      If(getIsLastCallofSimulation()) Then
		Return
      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Perform Any "After Convergence" Manipulations That May Be Required at the End of Each Timestep
      If(getIsEndOfTimestep()) Then
		Return
      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Do All of the "Very First Call of the Simulation Manipulations" Here
      If(getIsFirstCallofSimulation()) Then

		!Tell the TRNSYS Engine How This Type Works
		Call SetNumberofParameters(1)           !The number of parameters that the the model wants
		Call SetNumberofInputs(14)                   !The number of inputs that the the model wants
		Call SetNumberofDerivatives(0)         !The number of derivatives that the the model wants
		Call SetNumberofOutputs(37)                 !The number of outputs that the the model produces
		Call SetIterationMode(1)                             !An indicator for the iteration mode (default=1).  Refer to section 8.4.3.5 of the documentation for more details.
		Call SetNumberStoredVariables(0,0)                   !The number of static variables that the model wants stored in the global storage array and the number of dynamic variables that the model wants stored in the global storage array
		Call SetNumberofDiscreteControls(0)               !The number of discrete control functions set by this model (a value greater than zero requires the user to use Solver 1: Powell's method)

		Return

      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Do All of the First Timestep Manipulations Here - There Are No Iterations at the Intial Time
      If (getIsStartTime()) Then
	  ! Parameters
      P_low = getParameterValue(1)
	  ! Inputs
	  N_P1 = GetInputValue(1)
      N_P2 = GetInputValue(2)
      N_P3 = GetInputValue(3)
      N_P5 = GetInputValue(4)
	  f_V8 = GetInputValue(5)
	  f_V10 = GetInputValue(6)
	  f_V12 = GetInputValue(7)
	  f_V13 = GetInputValue(8)
	  f_V18 = GetInputValue(9)
	  f_V19 = GetInputValue(10)
	  f_V20 = GetInputValue(11)
      T_PL_out = GetInputValue(12)
      T_SL_out = GetInputValue(13)
      T_chwst = GetInputValue(14) ! Same as chilled water setpoint as of 9/13/2023

   !Set the Initial Values of the Outputs (#,Value)
    Call SetOutputValue(1, 1.d0) ! Outlet Air flow
    Call SetOutputValue(2, 1.d0) ! Outlet Air flow
    Call SetOutputValue(3, 1.d0) ! Outlet Air flow
    Call SetOutputValue(4, 1.d0) ! Outlet Air flow
    Call SetOutputValue(5, 1.d0) ! Outlet Air flow
    Call SetOutputValue(6, 1.d0) ! Outlet Air flow
    Call SetOutputValue(7, 1.d0) ! Outlet Air flow
    Call SetOutputValue(8, 1.d0) ! Outlet Air flow
    Call SetOutputValue(9, 1.d0) ! Outlet Air flow
    Call SetOutputValue(10, 1.d0) ! Outlet Air flow
    Call SetOutputValue(11, 1.d0) ! Outlet Air flow
    Call SetOutputValue(12, 1.d0) ! Outlet Air flow
    Call SetOutputValue(13, 1.d0) ! Outlet Air flow
    Call SetOutputValue(14, 1.d0) ! Outlet Air flow
    Call SetOutputValue(15, 1.d0) ! Outlet Air flow
    Call SetOutputValue(16, 1.d0) ! Outlet Air flow
    Call SetOutputValue(17, 1.d0) ! Outlet Air flow
    Call SetOutputValue(18, 1.d0) ! Outlet Air flow
    Call SetOutputValue(19, 1.d0) ! Outlet Air flow
    Call SetOutputValue(20, 1.d0) ! Outlet Air flow
    Call SetOutputValue(21, 1.d0) ! Outlet Air flow
    Call SetOutputValue(22, 1.d0) ! Outlet Air flow
    Call SetOutputValue(23, 1.d0) ! Outlet Air flow
    Call SetOutputValue(24, 1.d0) ! Outlet Air flow
    Call SetOutputValue(25, 1.d0) ! Outlet Air flow
    Call SetOutputValue(26, 1.d0) ! Outlet Air flow
    Call SetOutputValue(27, 1.d0) ! Outlet Air flow
    Call SetOutputValue(28, 1.d0) ! Outlet Air flow
    Call SetOutputValue(29, 1.d0) ! Outlet Air flow
    Call SetOutputValue(30, 1.d0) ! Outlet Air flow
    Call SetOutputValue(31, 1.d0) ! Outlet Air flow
	Call SetOutputValue(32, 1.d0) ! Outlet Air flow
	Call SetOutputValue(33, 1.d0) ! Outlet Air flow
	Call SetOutputValue(34, 1.d0) ! Outlet Air flow
	Call SetOutputValue(35, 1.d0) ! Outlet Air flow
    Call SetOutputValue(36, T_PL_out) ! Outlet Air flow
    Call SetOutputValue(37, T_SL_out) ! Outlet Air flow


		Return

      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!ReRead the Parameters if Another Unit of This Type Has Been Called Last
      If(getIsReReadParameters()) Then
		!Read in the Values of the Parameters from the Input File
      P_low = getParameterValue(1)

		
      EndIf
!-----------------------------------------------------------------------------------------------------------------------

!Read the Inputs

	  N_P1 = GetInputValue(1)
      N_P2 = GetInputValue(2)
      N_P3 = GetInputValue(3)
      N_P5 = GetInputValue(4)
	  f_V8 = GetInputValue(5)
	  f_V10 = GetInputValue(6)
	  f_V12 = GetInputValue(7)
	  f_V13 = GetInputValue(8)
	  f_V18 = GetInputValue(9)
	  f_V19 = GetInputValue(10)
	  f_V20 = GetInputValue(11)
      T_PL_out = GetInputValue(12)
      T_SL_out = GetInputValue(13)
      T_chwst = GetInputValue(14) 
 
      If(ErrorFound()) Return
!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!    *** PERFORM ALL THE CALCULATION HERE FOR THIS MODEL. ***
!-----------------------------------------------------------------------------------------------------------------------

	! Set low pressure level
	P(1) = P_low
	P(4) = P(1)
	P(7) = P(1)
	P(20) = P(1)
	P(19) = P(1)
	P(17) = P(1)
	P(15) = P(1)
	P(12) = P(1)
    
	!Secondary loop iteration 
	Q_SL = 30 !guess for secondary flow rate
	err_SL = 999 !initial error for iteration
	tol_SL = 0.01 !tolerance (relative)
	
    it = 0
	do while ((err_SL>tol_SL).and.(it < itMax) )
		call DP_P(N_P3,Q_SL,3,DP)
		P(13) = P(12) + DP !pressure rise across pump 3
		P(14) = P(13) !set pressures upstream of secondary loop pump
		P(16) = P(13)
		P(18) = P(13)
		call Q_V(f_V13, P(14) - P(15), 13, Q_AHU2) !flow through valve 13 (AHU2)
		call Q_V(f_V12, P(16) - P(17), 12, Q_AHU1) !flow through valve 12 (AHU1)
		call Q_V(f_V10, P(18) - P(19), 10, Q_HX1) !flow through valve 10 (HX1)
		Q_SL_c = Q_AHU1 + Q_AHU2 + Q_HX1 !calculated secondary loop flow
		err_SL=abs(Q_SL_c - Q_SL)/abs(Q_SL_c+0.01)
		Q_SL = Q_SL_c
        it = it + 1
	end do 
	! Do not allow negative flow rates
    if (Q_HX1 < 0) then
        Q_HX1 = 0
        Q_SL = Q_AHU1+Q_AHU2+Q_HX1
    endif
    if (Q_AHU1 < 0) then
        Q_AHU1 = 0
        Q_SL = Q_AHU1+Q_AHU2+Q_HX1
    endif
    if (Q_AHU2 < 0) then
        Q_AHU2 = 0
        Q_SL = Q_AHU1+Q_AHU2+Q_HX1
    endif

	! skip == 0 is the original version of the calculation using pressures in the system; it's a better approach, but it's wrong. Revisit
	! with better pressure measurements
	! skip == 1 is hardcoded; use the hardcoded flow rates in the primary loop for now
    skip = 1    
    if (skip == 0) then
        if((f_V18 + f_V19 + f_V20) < 1) then
            Q_PL = 0
            Q_C1 = 0
            Q_C2 = 0
        else
            !Primary loop 
            Q_PL = 5 !minimum value of Q_PL for search
            Q_PL_min = Q_PL
            DQ_PL = 1.5
            Q_PL_c = 1

            i = 0
            it = 0
            PLknown = 0
            do while ((Q_PL_c>0).and.(it < itMax)) !stop adding to vector when Q_PL_c = 0 
                call PrimaryLoop(P, Q_PL, f_V8, f_V18, f_V19, f_V20, N_P1, N_P2, N_P5, PLknown ,P,Q_PL_c,Q_BTSE,Q_TSE,Q_C1,Q_C2,Q_WSE)
                !add results to vectors 
                i = i+1
                Q_PLv(i) = Q_PL
                Q_PL_cv(i) = Q_PL_c
                Q_PL = Q_PL + DQ_PL
            end do 
            ! !find intersection point between Q_PL_c and Q_PL 
            errv = (Q_PL_cv - Q_PLv)    

            !call akimaip_ne(luw,19,errv,Q_PLv,1,0,Q_PL)
            !Q_PL = Q_PLv(1)+(-errv(1))*((Q_PLv(5)-Q_PLv(1))/(errv(5)-errv(1)))

            s = (/0,0/)
            if (i > 1) then
                    if (errv(1) < 0) then
                        s(2) = -1;
                    else
                        s(2) = 1;
                    end if
                    s(1) = s(2);
                    j = 2;
                    do while (((s(1)).eq.(s(2))).and.(j <= i)) 
                        s(2) = s(1)
                        if (errv(j) < 0) then
                            s(1) = -1
                        else
                            s(1) = 1
                        end if
                        idx = j
                        j = j + 1
                    end do
                    ys = (/idx-1,idx/)
                    xs = (/errv(idx-1),errv(idx)/)
                    ! Figure out ys where xs is 0
                    slope = (ys(1)-ys(2))/(xs(1)-xs(2))
                    intercept = ys(1)-slope*xs(1)
                    x_idx = 0*slope + intercept
                    Q_PL = Q_PL_min + DQ_PL*(x_idx-1)            
            end if        
        end if
        PLknown = 1
        call PrimaryLoop(P, Q_PL, f_V8, f_V18, f_V19, f_V20, N_P1, N_P2, N_P5, PLknown, P,Q_PL_c,Q_BTSE,Q_TSE,Q_C1,Q_C2,Q_WSE)   
    else
        if((f_V18 + f_V19 + f_V20) < 1) then
			! The chiller and water side economizer valves are closed, so set flow rates to 0
            Q_PL = 0
            Q_C1 = 0
            Q_C2 = 0
            Q_TSE = 0
        else
            call PrimaryLoop2(P, f_V8, f_V18, f_V19, f_V20, N_P1, N_P2, N_P5, P,Q_PL,Q_BTSE,Q_TSE,Q_C1,Q_C2,Q_WSE)
        endif
    endif
    Q_DC = Q_PL - Q_SL
		
	! Calculate pump powers
    call Pow_P(N_P3, Q_SL,3, power_P3)
    call Pow_P(N_P1, Q_C1,1, power_P1)
    call Pow_P(N_P2, Q_C2,2, power_P2)
    call Pow_P(N_P5, Q_WSE,5, power_P5)
    

    if (Q_PL > 0) then
		! T_SL_in is based on T_PL_out and the flow in the bridge. Estimate it's value based on 
		! the fraction of Q_SL and Q_PL. If it is greater than 1, then T_SL_in will be more influenced by
		! T_SL_out. The parameter values and the overall relationship are based on an energy balance and a fit
		! to data.
        mult = Q_SL/Q_PL
        T_SL_in = 2.206*mult-1.552+T_PL_out
    else
        T_SL_in = max(T_chwst,T_PL_out)
    endif
    
    if (Q_PL == 0) then
        T_PL_in = T_PL_out
    else
		! apply an energy balance to estimate T_PL_in
        T_PL_in = (Q_PL*T_PL_out+Q_SL*T_SL_out-Q_SL*T_SL_in)/Q_PL
    endif

!-----------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------
!Set the Outputs from this Model (#,Value)
    Call SetOutputValue(1, P(1)) ! Outlet Air flow
    Call SetOutputValue(2, P(2)) ! Outlet Air flow
    Call SetOutputValue(3, P(3)) ! Outlet Air flow
    Call SetOutputValue(4, P(4)) ! Outlet Air flow
    Call SetOutputValue(5, P(5)) ! Outlet Air flow
    Call SetOutputValue(6, P(6)) ! Outlet Air flow
    Call SetOutputValue(7, P(7)) ! Outlet Air flow
    Call SetOutputValue(8, P(8)) ! Outlet Air flow
    Call SetOutputValue(9, P(9)) ! Outlet Air flow
    Call SetOutputValue(10, P(10)) ! Outlet Air flow
    Call SetOutputValue(11, P(11)) ! Outlet Air flow
    Call SetOutputValue(12, P(12)) ! Outlet Air flow
    Call SetOutputValue(13, P(13)) ! Outlet Air flow
    Call SetOutputValue(14, P(14)) ! Outlet Air flow
    Call SetOutputValue(15, P(15)) ! Outlet Air flow
    Call SetOutputValue(16, P(16)) ! Outlet Air flow
    Call SetOutputValue(17, P(17)) ! Outlet Air flow
    Call SetOutputValue(18, P(18)) ! Outlet Air flow
    Call SetOutputValue(19, P(19)) ! Outlet Air flow
    Call SetOutputValue(20, P(20)) ! Outlet Air flow
    Call SetOutputValue(21, Q_PL) ! Outlet Air flow
    Call SetOutputValue(22, Q_SL) ! Outlet Air flow
    Call SetOutputValue(23, Q_AHU1) ! Outlet Air flow
    Call SetOutputValue(24, Q_AHU2) ! Outlet Air flow
    Call SetOutputValue(25, Q_BTSE) ! Outlet Air flow
    Call SetOutputValue(26, Q_TSE) ! Outlet Air flow
    Call SetOutputValue(27, Q_HX1) ! Outlet Air flow
    Call SetOutputValue(28, Q_C1) ! Outlet Air flow
    Call SetOutputValue(29, Q_C2) ! Outlet Air flow
    Call SetOutputValue(30, Q_DC) ! Outlet Air flow
    Call SetOutputValue(31, Q_WSE) ! Outlet Air flow
    Call SetOutputValue(32, power_P3) ! Outlet Air flow
    Call SetOutputValue(33, power_P1) ! Outlet Air flow
    Call SetOutputValue(34, power_P2) ! Outlet Air flow
    Call SetOutputValue(35, power_P5) ! Outlet Air flow
    Call SetOutputValue(36, T_SL_in) ! Outlet Air flow
    Call SetOutputValue(37, T_PL_in) ! Outlet Air flow

      Return
      End
!-----------------------------------------------------------------------------------------------------------------------
subroutine PrimaryLoop2(Pin, f_V8, f_V18, f_V19, f_V20, N_P1, N_P2, N_P5, Pout, Q_PL, Q_BTSE, Q_TSE, Q_C1, Q_C2, Q_WSE)
implicit none 
double precision f_V18, f_V19, f_V20, f_V8, N_P1, N_P2, N_P5, PLknown, Pin(20), Pout(20), Q_BTSE, Q_C1, Q_C2, Q_PL, Q_PL_c, Q_TSE, Q_WSE  
double precision DP_P1, DP_P1_max, DP_P2, DP_P2_max, DP_P5, DP_P5_max, err_BTSE, err_C1, err_C2, err_WSE, err_TSE,Q_C2_tes
double precision Q_BTSE_c, Q_TSE_c, Q_C1_c, Q_C2_c, Q_WSE_c, tol_BTSE, tol_TSE, tol_C1, tol_C2, tol_WSE, P(20), DP, frac, Q_C2_m, Q_C1_m
integer it, itMax
! This is the current way of calculating the primary loop flows, using hardcoded values
    itMax = 100
    Q_C2_m = 23	! Chiller2 flow when not charging the TES
    Q_C2_tes = 21 ! Chiller2 flow when charging the TES
    Q_C1_m = 21 ! Chiller1 flow
    if ((f_V18 > 0).and.(f_V8 > 0.1)) then
		! Charging
        Q_C2 = Q_C2_tes
    elseif (f_V18 > 0) then
		! not charging
        Q_C2 = Q_C2_m
    else
		! not using Chiller2
        Q_C2 = 0
    endif
        
    if (f_V19 > 0) then
		! using Chiller1
        Q_C1 = Q_C1_m
    else
		! not using Chiller1
        Q_C1 = 0
    endif
    ! Q_PL is the sum of Chiller1 and Chiller2 lows
    Q_PL = Q_C1 + Q_C2
    
    if (f_V8 == 1) then
		! There is no bypass flow
        Q_TSE = Q_PL
        Q_BTSE = 0
        frac = 1
		! Pressures currently aren't used, but calculate them anyway; hopefully can use in the future
		call DP_V(frac,Q_TSE,82,DP) !82 is through
		P(11) = P(12) + DP
		P(10) = P(11)
		P(9) = P(11)
		P(6) = P(11)
		P(3) = P(11)
    elseif (f_V8 == 0) then
		! The TES is fully bypassed
        Q_TSE = 0
		Q_BTSE = Q_PL
        frac = 1
		! Pressures currently aren't used, but calculate them anyway; hopefully can use in the future
		call DP_V(frac, Q_BTSE, 81,DP) !81 is bypass
		P(10) = P(12) + DP
		P(11) = P(10)
		P(9) = P(10)
		P(6) = P(10)
		P(3) = P(10)
    elseif (f_V8 <= 0.5) then
		! More flow through the bypass than the TES (discharge mode)
        Q_BTSE = Q_PL/2 !guess for thermal storage bypass flow
		err_BTSE = 999 !initial value of error
		tol_BTSE = 0.01 !tolerance (relative)
        it = 0
		do while ((err_BTSE>tol_BTSE).and.(it < itMax)) 
			! Pressures are used to estimate the bypass flow rate
			call DP_V(1.0-f_V8, Q_BTSE, 81, DP) !81 is bypass
			P(10) = P(12) + DP
			P(11) = P(10)
			P(9) = P(10)
			P(6) = P(10)
			P(3) = P(10)
			call Q_V(f_V8, P(11) - P(12), 82, Q_TSE) !82 is through
			Q_BTSE_c = Q_PL - Q_TSE
			err_BTSE = abs(Q_BTSE_c - Q_BTSE)/abs(Q_BTSE)
			Q_BTSE = Q_BTSE_c
            it = it + 1
		end do 
    else
		! More flow through the TES than the bypass (discharge mode)
		Q_TSE = Q_PL/2 !guess for thermal storage flow
		err_TSE = 999 !initial value of error
		tol_TSE = 0.01 !tolerance (relative)
        it = 0
		do while ((err_TSE>tol_TSE).and.(it < itMax)) 
			! Pressures are used to estimate the bypass flow rate
			call DP_V(f_V8,Q_TSE,82,DP) !82 is through TES
			P(11) = P(12) + DP
			P(10) = P(11)
			P(9) = P(10)
			P(6) = P(10)
			P(3) = P(10)
			call Q_V(1-f_V8, P(10) - P(12), 81, Q_BTSE) !81 is bypass
			Q_TSE_c = Q_PL - Q_BTSE
			err_TSE = abs(Q_TSE_c - Q_TSE)/abs(Q_TSE)
			Q_TSE = Q_TSE_c
            it = it+1
		end do
	end if 
    ! Estimate pressure rises across pumps
    if (f_V18 > 0) then
        call DP_P(N_P1,Q_C1,1, DP_P1) !pressure rise across pump 1
        P(5) = P(6) - DP_P1
    else
        P(5) = P(6)
    endif
    if (f_V19 > 0) then
        call DP_P(N_P2,Q_C2,2, DP_P2) !pressure rise across pump 21
        P(2) = P(3) - DP_P2
    else
        P(2) = P(3)
    endif
    
    Pout = P
    
    return
    end

subroutine PrimaryLoop(Pin, Q_PL, f_V8, f_V18, f_V19, f_V20, N_P1, N_P2, N_P5,PLknown, Pout, Q_PL_c, Q_BTSE, Q_TSE, Q_C1, Q_C2, Q_WSE)
implicit none 
double precision f_V18, f_V19, f_V20, f_V8, N_P1, N_P2, N_P5, PLknown, Pin(20), Pout(20), Q_BTSE, Q_C1, Q_C2, Q_PL, Q_PL_c, Q_TSE, Q_WSE  
double precision DP_P1, DP_P1_max, DP_P2, DP_P2_max, DP_P5, DP_P5_max, err_BTSE, err_C1, err_C2, err_WSE, err_TSE
double precision Q_BTSE_c, Q_TSE_c, Q_C1_c, Q_C2_c, Q_WSE_c, tol_BTSE, tol_TSE, tol_C1, tol_C2, tol_WSE, P(20), DP, frac
integer it, itMax
	! original version of the code to calculate the primary loop flow rates; not currently used
    itMax = 100

	P = Pin
	!thermal storage 
	if (f_V8==1) then !all flow goes through thermal storage and none through bypass
		Q_TSE = Q_PL
		Q_BTSE = 0
        frac = 1
		call DP_V(frac,Q_TSE,82,DP) !82 is through
		P(11) = P(12) + DP
		P(10) = P(11)
		P(9) = P(11)
		P(6) = P(11)
		P(3) = P(11)
	else if (f_V8==0) then !all flow goes through bypass and none through thermal storage
		Q_TSE = 0
		Q_BTSE = Q_PL
        frac = 1
		call DP_V(frac, Q_BTSE, 81,DP) !81 is bypass
		P(10) = P(12) + DP
		P(11) = P(10)
		P(9) = P(10)
		P(6) = P(10)
		P(3) = P(10)
	else if (f_V8<=0.5) then !flow is split somehow between bypass and thermal storage
		Q_BTSE = Q_PL/2 !guess for thermal storage bypass flow
		err_BTSE = 999 !initial value of error
		tol_BTSE = 0.01 !tolerance (relative)
        it = 0
		do while ((err_BTSE>tol_BTSE).and.(it < itMax)) 
			call DP_V(1.0-f_V8, Q_BTSE, 81, DP) !81 is bypass
			P(10) = P(12) + DP
			P(11) = P(10)
			P(9) = P(10)
			P(6) = P(10)
			P(3) = P(10)
			call Q_V(f_V8, P(11) - P(12), 82, Q_TSE) !82 is through
			Q_BTSE_c = Q_PL - Q_TSE
			err_BTSE = abs(Q_BTSE_c - Q_BTSE)/abs(Q_BTSE)
			Q_BTSE = Q_BTSE_c
            it = it + 1
		end do 
	else
		Q_TSE = Q_PL/2 !guess for thermal storage flow
		err_TSE = 999 !initial value of error
		tol_TSE = 0.01 !tolerance (relative)
        it = 0
		do while ((err_TSE>tol_TSE).and.(it < itMax)) 
			call DP_V(f_V8,Q_TSE,82,DP) !82 is through
			P(11) = P(12) + DP
			P(10) = P(11)
			P(9) = P(10)
			P(6) = P(10)
			P(3) = P(10)
			call Q_V(1-f_V8, P(10) - P(12), 81, Q_BTSE) !81 is bypass
			Q_TSE_c = Q_PL - Q_BTSE
			err_TSE = abs(Q_TSE_c - Q_TSE)/abs(Q_TSE)
			Q_TSE = Q_TSE_c
            it = it+1
		end do
	end if 

	!Chiller 1 loop 
	if (f_V19==0) then 
		Q_C1 = 0
		P(5) = P(6)
	else
		call DP_P(N_P1,0.0,1, DP_P1_max) !maximum possible pressure rise across pump 1
		if ((P(6) - P(4)) > DP_P1_max) then 
			Q_C1 = 0
			P(5) = P(6)
		else if (PLknown < 1) then
			Q_C1 = 20 !guess for chiller 1 flow rate
			err_C1 = 999 !initial value for error
			tol_C1 = 0.01 !tolerance (relative)
            it = 0
			do while ((err_C1 > tol_C1).and.(it < itMax)) 
				call DP_P(N_P1,Q_C1,1, DP_P1) !pressure rise across pump 1
				P(5) = P(6) - DP_P1
				call Q_V(f_V19,P(4) - P(5),19, Q_C1_c) !flow through valve 18
				err_C1 = abs(Q_C1_c - Q_C1)/abs(Q_C1_c) !error in pressure drop
				Q_C1 = Q_C1_c
                it = it + 1
			end do 
            Q_C1 = 21
        else
            Q_C1 = Q_PL
            call DP_P(N_P1,Q_C1,1, DP_P1) !pressure rise across pump 1
			P(5) = P(6) - DP_P1
		end if 
	end if 

	!Chiller 2 loop 
	if (f_V18==0) then 
		Q_C2 = 0
		P(2) = P(3)
	else
		call DP_P(N_P2,0.0,2, DP_P2_max) !maximum pressure rise for P2
		if ((P(3)-P(1)) > DP_P2_max) then 
			Q_C2 = 0
			P(2) = P(3)
		else if (PLknown < 1) then
			Q_C2 = 20 !guess for chiller 2 flow rate
			err_C2 = 999 !initial value for error
			tol_C2 = 0.01 !tolerance (relative)
            it = 0
			do while ((err_C2 > tol_C2).and.(it < itMax)) 
				call DP_P(N_P2,Q_C2,2, DP_P2) !pressure rise across pump 21
				P(2) = P(3) - DP_P2
                call Q_V(f_V18,P(1) - P(2),18, Q_C2_c) !flow through valve 19
                err_C2 = abs(Q_C2_c - Q_C2)/abs(Q_C2_c) !error in pressure drop
                Q_C2 = Q_C2_c
                it = it + 1
			end do 	
        else
            Q_C2 = Q_PL
            call DP_P(N_P2,Q_C2,2, DP_P2) !pressure rise across pump 21
			P(2) = P(3) - DP_P2
		end if 
	end if 

	!WSE loop 
	if (f_V20==0) then 
		Q_WSE = 0
		P(8) = P(7)
	else
		call DP_P(N_P5,0.0,5, DP_P5_max) !maximum possible pressure rise for pump 5
		if ((P(9) - P(7)) > DP_P5_max) then 
			Q_WSE = 0
			P(8) = P(7)
		else
			Q_WSE = 20 !guess for WSE flow rate
			err_WSE = 999 !initial value for error
			tol_WSE = 0.01 !tolerance (relative)
            it = 0
			do while ((err_WSE > tol_WSE).and.(it < itMax))
				call DP_P(N_P5,Q_WSE,5, DP_P5) !pressure rise across pump 5
				P(8) = P(7) + DP_P5
				call Q_V(f_V20,P(8) - P(9),20, Q_WSE_c) !flow through valve 20
				err_WSE = abs(Q_WSE_c - Q_WSE)/abs(Q_WSE_c) !error in pressure drop
				Q_WSE = Q_WSE_c
                it = it + 1
			end do 
		end if 
	end if 
	
	Q_PL_c = Q_C1 + Q_C2 + Q_WSE
	Pout = P
	
	return
	end
 
 subroutine Q_V(frac, DP, ValveID, Q_valve)
	implicit none 
	double precision DP, frac, Q_valve, dDPdQ, DP_c, DP_cp, dQ, error, flip, Q, tol
	integer ValveID, it, itMax
    itMax = 1000
	! 
	! Calculate the flow rate through valve (Q_valve) in (gpm) given its fractional open 
	! Calculate pressure drop by calling the function DP_valve
	! 
	! frac = fractional open (0-1, corresponds to 0 or closed to 100 or fully open) 
	! DP = pressure drop across valve (psi) 
	! ValveID = number that identifies valve 
	if ((frac==0).or.(DP == 0)) then 
		Q_valve=0
        close(unit = 102)
		return
	end if 
	if (DP<0) then 
		DP=-DP
		flip=1
	else
		flip=0
	end if 

	Q=15
	error=999
	tol = 0.001
    it = 0
	do while ((error>tol).and.(it < itMax)) 
		call DP_V(frac, Q, ValveID, DP_c)
		dQ = 0.01*Q
		call DP_V(frac, Q+dQ, ValveID, DP_cp)
		dDPdQ = (DP_cp-DP_c)/dQ
		Q = Q+(DP-DP_c)/dDPdQ
		error = abs(DP_c-DP)/DP
        it = it + 1
	end do 
	Q_valve = Q
	if (flip==1) then 
		Q_valve = -Q_valve
	end if 
	close(unit = 102)
	return
	end

 Subroutine DP_V(frac, Q, ValveID, DP_valve)
implicit none 
double precision DP_valve, frac, Q, DP_nom, flip, Q_nom, Q_nom_adj, Q_ratio, y(16)
integer ValveID  
!  Calculates pressure drop across valve (DP_valve) in (psi) given its fractional open and flow rate 
! 
! frac = fractional open (0-1, 0 = closed, 1 = fully open) 
! Q = flow through valve (gpm) 
! ValveID = number that identifies valve 

! Fit  
    !Original values
    y = (/20.0,11.0,20.0,11.0,39.0,19.0,7.2,19.0,7.2,19.0,22.0,25.0,22.0,25.0,22.0,25.0/)
     
	if (Q<0) then 
		Q=-Q
		flip=1
	else
		flip=0
	end if 
	
	select case (ValveID)
		case (81) !valve 8 through bypass path (1-f_V8)
		Q_nom = y(1)
		DP_nom = y(2)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (82) !valve 8 through thermal storage path f_V8
		Q_nom = y(3)
		DP_nom = y(4)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (10)
		Q_nom = y(5)
		DP_nom = y(6)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (12)
		Q_nom = y(7)
		DP_nom = y(8)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (13)
		Q_nom = y(9)
		DP_nom = y(10)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (18)
		Q_nom = y(11)
		DP_nom = y(12)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (19)
		Q_nom = y(13)
		DP_nom = y(14)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case (20)
		Q_nom = y(15)
		DP_nom = y(16)
		Q_nom_adj = Q_nom*frac
		Q_ratio = Q/(Q_nom_adj)
		DP_valve = DP_nom*Q_ratio*Q_ratio
		case default 
		error('ValveID is not recognized in DP_Valve')
		end select 
	if (flip==1) then 
		DP_valve = -DP_valve
	end if 
	
	return
	end

 Subroutine DP_P(N, Q, PumpID, DP_pump)
implicit none 
	double precision DP_pump, N, Q, DP_pump_max, N_ratio, Q_pump_max, Q_ratio, DP_pump_ratio, y(24)
	integer PumpID
	! Calculates pressure drop produced by a pump (DP_pump) in (psi) given the flow through the pump and its speed 
	! 
	! speed = speed of pump (rpm) 
	! Q = flow through pump (gpm) 
	! PumpID = number that identifies pump 

! Fit
    y = (/8E-6,-4E-5,-0.0156,0.0346,0.0,-0.4183,0.0194,1.0,&
          2E-6,0.0006,0.0,0.0184,-10.501,-0.5643,-0.0494,1.0,&
          7E-6,1E-7,-0.0002,0.0328,0.0,-0.4177,0.0021,1.0/)

        
	if (Q<0) then 
		Q=0
	end if 
	select case (PumpID)
		case (1)
		if (N==0) then
			DP_pump = 0
		else
			DP_pump_max = y(1)*N**2 + y(2)*N + y(3)
			Q_pump_max = y(4)*N + y(5)
			Q_ratio = Q/(Q_pump_max)
			DP_pump_ratio = y(6)*Q_ratio**2 + y(7)*Q_ratio + y(8)
			DP_pump = DP_pump_max*DP_pump_ratio
		end if
        case (2)
		if (N==0) then
			DP_pump = 0
		else
			DP_pump_max = y(9)*N**2 + y(10)*N + y(11)
			Q_pump_max = y(12)*N + y(13)
			Q_ratio = Q/(Q_pump_max)
			DP_pump_ratio = y(14)*Q_ratio**2 + y(15)*Q_ratio + y(16)
			DP_pump = DP_pump_max*DP_pump_ratio
		end if
        case (3)
		if (N==0) then
			DP_pump = 0
		else
			DP_pump_max = y(17)*N**2 + y(18)*N + y(19)
			Q_pump_max = y(20)*N+y(21)
			Q_ratio = Q/(Q_pump_max)
			DP_pump_ratio = y(22)*Q_ratio**2 + y(23)*Q_ratio + y(24)
			DP_pump = DP_pump_max*DP_pump_ratio
		end if
        case (5)
		if (N==0) then
			DP_pump = 0
		else
			DP_pump_max = 6E-6*N**2 - 0.0005*N
			Q_pump_max = 0.0352*N - 11.213
			Q_ratio = Q/(Q_pump_max)
			DP_pump_ratio = -0.4571*Q_ratio**2 + 0.0912*Q_ratio + 1
			DP_pump = DP_pump_max*DP_pump_ratio
        end if
		case default 
		error('PumpID is not recognized in DP_pump')
	end select 
	
	return
    end

    
 Subroutine Pow_P(N, Q, PumpID, power_pump)
implicit none 
	double precision power_pump, N, Q, power_pump_max, N_ratio, Q_pump_max, Q_ratio, power_pump_ratio,x(7)
	integer PumpID
	! DCalcualtes pump power consumption in (W) given the flow through the pump and its speed 
	! 
	! speed = speed of pump (rpm) 
	! Q = flow through pump (gpm) 
	! PumpID = number that identifies pump 
	if (Q<0) then 
		Q=0
	end if 
	select case (PumpID)
		case (1)
        x = (/0.014,-2.75,192.37,8.82,129.25,4.36,0.0165/)  ! N in rpm
        case (2)
        x = (/0.019,-20.5,0.82,6.88,66.43,20.20,0.011/) ! N in rpm        
        case (3)
        x = (/0.0109,-9.23,101.7,-5.02,-9.63,-5.3,0.031/) ! N in rpm        
        case (5)
		x = (/0.0004,-0.3843,153.65,0.0352,-11.213,0.2748,0.7849/) ! N in rpm
		case default 
		error('PumpID is not recognized in Pow_P')
	end select 
    if (N == 0) then
        power_pump = 0
    else
		power_pump_max = x(1)*N**2 + x(2)*N + x(3)
		Q_pump_max = x(4)*N + x(5)
		Q_ratio = Q/(Q_pump_max)
		power_pump_ratio = x(6)*Q_ratio + x(7)
		power_pump = power_pump_max*power_pump_ratio
    end if
    power_pump = max(power_pump,0.d0)
    	
	return
	end


